#!/usr/bin/env python3
# encoding: utf-8
'''
PDF to Islandora Book Batch converter

Created by Jared Whiklo on 2016-03-16.
Copyright (c) 2016 University of Manitoba Libraries. All rights reserved.
''' 
import sys, os
import argparse
import re
import logging, logging.config
import subprocess
import time
import PyPDF2
import html
import shutil
import lxml.etree as ET
import copy

'''logger placeholder'''
logger = None

'''External programs needed for this to operate'''
required_programs = [
    {'exec' : 'gs', 'check_var' : '--help'},
    {'exec' : 'tesseract', 'check_var' : '-v'},
    {'exec' : 'convert', 'check_var' : '-version' },
    {'exec' : 'identify', 'check_var' : '-version'},
    {'exec' : 'kdu_compress', 'check_var' : '-version'}
]

'''Options dictionary placeholder, generated by ArgumentParser'''
options =  None

'''Regex - Count pages from parsed PDF.'''
rxcountpages = re.compile(b"/Type\s*/Page([^s]|$)", re.MULTILINE|re.DOTALL)
'''Regex - Match HTML tags'''
htmlmatch = re.compile(r'<[^>]+>', re.MULTILINE|re.DOTALL)
'''Regex - Match blank lines/characters'''
blanklines = re.compile(r'^[\x01|\x0a|\s]*$', re.MULTILINE)

def processPdf(pdf):
    '''Parse a PDF and produce derivatives

    Keyword arguments
    pdf -- The full path to the PDF file
    '''
    logger.info("Processing {}".format(pdf))
    # Check for an existing directory
    book_name = os.path.splitext(os.path.split(pdf)[1])[0]
    book_dir = os.path.join(os.path.dirname(pdf), book_name + '_dir')
    mods_file = None
    if not os.path.exists(book_dir):
        os.mkdir(book_dir)
    if options.mods_dir is not None:
        tmpfile = os.path.join(options.mods_dir, book_name + '.mods')
        logger.debug("We have a MODS directory to use {}, look for file {}".format(options.mods_dir, tmpfile))
        if os.path.exists(tmpfile) and os.path.isfile(tmpfile):
            logger.debug("Found file {} and it is a file.".format(tmpfile))
            mods_file = os.path.join(book_dir, 'MODS.xml')
            logger.debug("copy file to {} and set that as mods_file".format(mods_file))
            shutil.copyfile(tmpfile, mods_file)

    pages = countPages(pdf)
    logger.debug("counted {} pages in {}".format(pages, pdf))
    
    for p in list(range(1, pages)):
        logger.info("Processing page {}".format(str(p)))
        outDir = os.path.join(book_dir, str(p))
        if not os.path.exists(os.path.join(book_dir, str(p))):
            logger.debug("Creating directory for page {} in {}".format(p, book_dir))
            os.mkdir(os.path.join(book_dir, outDir))
        newPdf = getPdfPage(pdf, p, outDir)
        tiffFile = getTiff(newPdf, outDir)
        hocrFile = getHocr(tiffFile, outDir)
        getOcr(tiffFile, hocrFile, outDir)
        getJpegs(tiffFile, outDir)
        if mods_file is not None:
            logger.debug("We have a mods_file.")
            # Copy mods file and insert 
            makePageMods(filename=mods_file, output_dir=os.path.join(book_dir, outDir), page=p)
    # Last copy the original PDF to the book level as PDF.pdf
    shutil.copy(pdf, os.path.join(book_dir, 'PDF.pdf'))


def getTiff(newPdf, outDir):
    '''Produce a single page Tiff from a single page PDF

    Keyword arguments
    newPdf -- The full path to the PDF file
    outDir -- The directory to save the single page Tiff to
    '''
    logger.debug("in getTiff")
    device = 'tiff32nc'
    resolution = options.resolution
    # Increase density by 25%, then resize to only 75%
    altered_resolution = int(resolution * 1.25)
    output_file = os.path.join(outDir, 'OBJ.tiff')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        # Delete the file if it exists AND we set --overwrite
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    
    if not os.path.exists(output_file):
        # Only run if the file doesn't exist.
        logger.debug("Generating Tiff")
        op = ['convert', '-density', str(altered_resolution), newPdf, '-resize', '75%', '-colorspace', 'rgb', '-alpha', 'Off', output_file]
        if not doSystemCall(op):
            quit()
    return output_file
            

def getJpegs(tiffFile, outDir):
    '''Produce the needed JPEGs for ingest.

    Keyword arguments
    tiffFile -- The tiff file
    outDir -- The directory to save the images to.
    '''
    makeJpeg2000(tiffFile, outDir)
    makeJpeg(tiffFile, outDir, 'JPG', height=800, width=800)
    makeJpeg(tiffFile, outDir, 'TN', height=110, width=110)

def makeJpeg2000(tiffFile, outDir):
    size = getImageSize(tiffFile)
    res = getImageResolution(tiffFile)
    #loseless = (size['height'] < 1024 or size['width'] < 1024 or res['x'] < 300 or res['y'] < 300)
    loseless = True
    justFile = os.path.split(tiffFile)[1]
    output_file = os.path.join(outDir, 'JP2.jp2')
    
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        logger.debug("Generating Jpeg2000")

        if isCompressed(tiffFile):
            newFile = os.path.join(os.path.dirname(tiffFile), os.path.splitext(justFile)[0] + "_tmp" + os.path.splitext(justFile)[1])
            op = ['convert', '-compress', 'None', tiffFile, newFile]
            doSystemCall(op)
        else:
            newFile = tiffFile
        if getBitDepth(tiffFile) > 8:
            # Use Kakadu
            op = ['kdu_compress', '-i', newFile, '-o', output_file]
            if loseless:
                # Do loseless
                op.extend(['Creversible=yes', '-rate', '-,1,0.5,0.25', 'Clevels=5'])
            else:
                op.extend(['-rate', '0.5', 'Clayers=1', 'Clevels=7', 'Cprecincts={256,256},{256,256},{256,256},{128,128},{128,128},{64,64},{64,64},{32,32},{16,16}', 'Corder=RPCL', 'ORGgen_plt=yes', 'ORGtparts=R', 'Cblk={32,32}', 'Cuse_sop=yes'])
        else:
            # Use ImageMagick
            op = ['convert']
            op.extend(imageMagickOpts(loseless))
            op.extend([newFile, output_file])

        doSystemCall(op)

        if newFile != tiffFile:
            # If we made an uncompressed copy, delete it.
            os.remove(newFile)

def makeJpeg(tiffFile, outDir, outName, height=None, width=None):
    '''Make a Jpeg of max size height x width'''

    op = ['convert', tiffFile]

    output_file = os.path.join(outDir, outName + '.jpg')

    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        logger.debug("Creating JPEG with size maximum width and height {}x{}".format(width, height))
        if height is not None or width is not None:
            op.append('-resize')
            if height is not None and width is not None:
                op.append("{}x{}".format(width, height))
            elif width is not None:
                op.append(width)
            else:
                op.append("x{}".format(height))
        op.append(output_file)

        doSystemCall(op)

def imageMagickOpts(lossless=False):
    '''Stores and returns the Kakadu JP2 creation args'''
    args = []
    args.append(" -depth 8")
    args.append(" -define jp2:tilewidth=1024")
    args.append(" -define jp2:tileheight=1024")
    if lossless:
        args.append(" -define numrlvls=6")
        args.append(" -define jp2:rate=1.0")
        args.append(" -define jp2:lazy")
        args.append(" -define jp2:prg=rlcp")
        args.append(" -define jp2:ilyrrates='0.015625,0.01858,0.0221,0.025,0.03125,0.03716,0.04419,0.05,0.0625,0.075,0.088,0.1,0.125,0.15,0.18,0.21,0.25,0.3,0.35,0.4,0.5,0.6,0.7,0.84'")
        args.append(" -define jp2:mode=int")
    else:
        args.append("-define numrlvls=7")
        args.append("-define jp2:rate=0.02348")
        args.append("-define jp2:prg=rpcl")
        args.append("-define jp2:mode=int")
        args.append("-define jp2:prcwidth=16383")
        args.append("-define jp2:prcheight=16383")
        args.append("-define jp2:cblkwidth=64")
        args.append("-define jp2:cblkheight=64")
        args.append("-define jp2:sop")
    return args

def isCompressed(imageFile):
    '''Does identify see compression on the file.'''
    logger.debug("Checking compression for {}".format(imageFile))
    op = ['identify', '-format', '%[C]', imageFile]
    result = doSystemCall(ops=op, returnResult=True)
    return result.rstrip('\r\n') != "None"

def getBitDepth(imageFile):
    '''Return the bit depth'''
    op = ['identify', '-format', '%[depth]', imageFile]
    result = doSystemCall(ops=op, returnResult=True)
    result = result.rstrip('\r\n')
    logger.debug("Getting the bit depth ({}) for {}".format(result, imageFile))
    return int(result)


def getImageSize(imageFile):
    '''Return a dict of the height and width of the image'''
    logger.debug("Getting the height and width of {}".format(imageFile))
    op = ['identify', '-format', '%[height]-%[width]', imageFile]
    result = doSystemCall(ops=op, returnResult=True)
    res_list = result.rstrip('\r\n').split('-')
    return {'height' : int(res_list[0]), 'width' : int(res_list[1])}

def getImageResolution(imageFile):
    '''Return a dict of the X and Y resolutions of the image'''
    logger.debug("Getting the resolutions of {}".format(imageFile))
    op = ['identify', '-format', '%x-%y', imageFile]
    result = doSystemCall(ops=op, returnResult=True)
    result = result.rstrip('\r\n')
    if result.lower().find("undefined"):
        result = result.lower().replace("undefined", "")
    res_list = result.split('-')
    return {'x' : int(res_list[0].strip()), 'y' : int(res_list[1].strip())}


def getPdfPage(pdf, page, outDir):
    '''Produce a single page PDF from a multi-page PDF

    Keyword arguments
    pdf -- The full path to the PDF file
    page -- The page to extract
    outDir -- The directory to save the single page PDF to

    Returns the path to the new PDF file
    '''
    output_file = os.path.join(outDir, 'PDF.pdf')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        # Delete the file if it exists AND we set --overwrite
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))        
    
    if not os.path.exists(output_file):
        # Only run if the file doesn't exist.
        logger.debug("Generating PDF for page {}".format(str(page)))
        op = ['gs', '-q', '-dNOPAUSE', '-dBATCH', '-dSAFER', '-sDEVICE=pdfwrite', '-sOutputFile={}'.format(output_file),
        '-dFirstPage={}'.format(str(page)), '-dLastPage={}'.format(str(page)), pdf ]
        if not doSystemCall(op):
            quit()
    return output_file

def getOcr(tiffFile, hocrFile, outDir):
    '''Which way to get OCR.

    Keyword arguments
    tiffFile -- Tiff file to process from
    hocrFile -- Hocr file to extract from
    outDir -- Directory to write OCR file to.
    '''
    if tiffFile is not None and os.path.exists(tiffFile) and os.path.isfile(tiffFile) and not options.use_hocr:
        processOCR(tiffFile, outDir)
    elif hocrFile is not None and os.path.exists(hocrFile) and os.path.isfile(hocrFile) and options.use_hocr:
        getOcrFromHocr(hocrFile, outDir)
    else:
        logger.error("Unable to generate OCR")

def getOcrFromHocr(hocrFile, outDir):
    '''Extract OCR from the Hocr data

    Keyword arguments
    hocrFile -- The HOCR file
    outDir -- Directory to write OCR file to.
    '''
    output_file = os.path.join(outDir, 'OCR.txt')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))    
    if not os.path.exists(output_file):
        logger.debug("Generating OCR.")     
        data = ''
        with open(hocrFile, 'r') as fpr:
            data += fpr.read()
        data = html.unescape(blanklines.sub('', htmlmatch.sub('\1', data)))
        with open(output_file, 'w') as fpw:            
            fpw.write(data)        
        
def processOCR(tiffFile, outDir):
    '''Get the OCR from a Tiff file.

    Keyword arguments
    tiffFile -- The TIFF image
    outDir -- The output directory'''
    output_file = os.path.join(outDir, 'OCR');
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating OCR.")
        op = ['tesseract', tiffFile, output_file, '-l', options['language']]
        if not doSystemCall(op):
            quit()
        
def getHocr(tiffFile, outDir):
    '''Get the HOCR from a Tiff file.

    Keyword arguments
    tiffFile -- The TIFF image
    outDir -- The output directory'''
    output_stub = os.path.join(outDir, 'HOCR');
    tmp_file = output_stub + '.hocr'
    output_file = output_stub + '.html'
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating HOCR.")
        op = ['tesseract', tiffFile, output_stub, '-l', options.language, 'hocr']
        if not doSystemCall(op):
            quit()
        os.rename(tmp_file, output_file)
        if os.path.exists(output_stub + '.txt') and options.use_hocr:
            # Some tesseracts seem to generate OCR at the same time as HOCR,
            # so lets move it to OCR if we are going to create OCR from HOCR.
            os.rename(output_stub + '.txt', os.path.join(outDir, 'OCR.txt'))
    return output_file

def makePageMods(filename, output_dir, page):
    '''Using a Book level MODS record insert the relatedItem/part information
    
    Keyword arguments
    filename -- The filename of the top level MODS file
    output_dir -- The page level directory to save the MODS to
    page -- The page number'''
    mods_namespace = '{http://www.loc.gov/mods/v3}'
    logger.debug("In makePageMods")
    if os.path.exists(filename) and os.path.isfile(filename):
        logger.debug("Have file {}".format(filename))
        try:
            tree = ET.parse(filename)
        except:
            logger.error("Error parsing MODS in file {}: {}".format(filename, sys.exc_info()[0]))
            return
        related = tree.find("{0}relatedItem[@type=\"host\"]".format(mods_namespace))
        if related is None:
            root = tree.getroot()
            related = ET.SubElement(root, "{0}relatedItem".format(mods_namespace), {'type' : 'host'})
        if related.find("{0}titleInfo/{0}title".format(mods_namespace)) is None:
            title = tree.find("{0}titleInfo/{0}title".format(mods_namespace))
            if title is None:
                logger.warning("Unable to locate the title page {}".format(page))
            else:
                tmp = ET.Element("{0}titleInfo".format(mods_namespace))
                tmp.append(copy.deepcopy(title))
                related.append(tmp)
                logger.debug("Copied titleInfo to relatedItem, now add page number to top level titleInfo/title")
                title.text = title.text + ' (Page {})'.format(page)
        part = related.find("{0}path".format(mods_namespace))
        if part is None:
            part = ET.SubElement(related, '{0}part'.format(mods_namespace))
        extent = part.find("{0}extent[@unit=\"pages\"]".format(mods_namespace))
        if extent is None:
            extent = ET.SubElement(part, "{0}extent".format(mods_namespace), {'unit' : 'pages'})
        start = extent.find("./{0}start".format(mods_namespace))
        if start is not None:
            start.getparent().remove(start)
        start = ET.SubElement(extent, '{0}start'.format(mods_namespace))
        start.text = str(page)
        end = extent.find('./{0}end'.format(mods_namespace))
        if end is not None:
            end.getparent().remove(end)
        end = ET.SubElement(extent, '{0}end'.format(mods_namespace))
        end.text = str(page)
        # Remove the book level page count
        phys_desc = tree.find("{0}physicalDescription/{0}extent[@unit=\"page\"]".format(mods_namespace))
        if phys_desc is not None:
            phys_desc.getparent().remove(phys_desc)

        try:
            tree.write(os.path.join(output_dir, 'MODS.xml'), encoding='utf-8', xml_declaration=True, method='xml')
        except IOError as e:
            logger.error("Error writing out page level MODS to directory {}: {}".format(output_dir, e.getMessage()))
            
            
        
def doSystemCall(ops, returnResult=False):
    '''Execute an external system call

    Keyword arguments
    ops -- a list of the executable and any arguments.
    returnResult -- return the result of the call if successful.
    '''
    try:
        process = subprocess.Popen(ops, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        try:
            outs, errs = process.communicate(timeout=60)
            if not process.returncode == 0:
                logger.error("Error executing command: \n{}\nOutput: {}\nError: {}".format(' '.join(ops), outs, errs))
                return False
        except TimeoutError:
            logger.error("Error executing command: \n{}\nMessage: {}\nOutput: {}\nSTDOUT: ".format(e.cmd, e.stderr, e.output, e.stdout))
            return False
    except subprocess.CalledProcessError as e:
        logger.error("Error executing command: \n{}\nMessage: {}\nOutput: {}\nSTDOUT: ".format(e.cmd, e.stderr, e.output, e.stdout))
        return False
    if returnResult:
        return outs
    else:
        return True

def countPages(pdf):
    '''Count the number of pages in a PDF

    Keyword arguments
    pdf -- the full path to the PDF file
    '''
    count = 0
    with open(pdf, 'rb') as fp:
        count += len(rxcountpages.findall(fp.read()))
    if count == 0:
        pdfRead = PyPDF2.PdfFileReader(pdf)
        count = pdfRead.getNumPages()
        pdfRead = None
    return count

def parseDir(theDir):
    '''Act on all PDFs in a directory, not recursing down.

    Keyword arguments
    theDir -- The full path to the directory to operate on
    '''
    files = [f for f in os.listdir(theDir) if re.search('.*\.pdf$', f)]
    for f in files: 
        processPdf(os.path.join(theDir, f))

def setUp(args):
    '''Do setup functions

    Keyword arguments
    args -- the ArgumentParser object
    '''
    global options
    options = args
    setupLog()
    try:
        for prog in required_programs:
            subprocess.run([prog.get('exec'), prog.get('check_var')], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except FileNotFoundError as e:
        print("A required program could not be found: {}".format(e.strerror.split(':')[1]))
        quit()

def setupLog():
    '''Setup logging'''
    global logger
    logger = logging.getLogger('pdf2book')
    logger.propogate = False
    # Logging Level 
    eval('logger.setLevel(logging.{})'.format(options.debug_level))
    fh = logging.FileHandler(os.path.join(os.path.dirname(__file__), 'pdf2book.log'), 'w', 'utf-8')
    formatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
    fh.setFormatter(formatter)
    logger.addHandler(fh)
    
def formatTime(seconds):
    '''Format seconds '''
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    return "%d:%02d:%02d" % (h, m, s)

def main():
    '''The main body of code'''
    start_time = time.perf_counter()
    
    parser = argparse.ArgumentParser(description='Turn a PDF or set of PDFs into properly formatted directories for Islandora Book Batch.')
    parser.add_argument('files', help="A PDF file or directory of PDFs to process.")
    parser.add_argument('--password', dest="password", default='', help='Password to use when parsing the PDFs.')
    parser.add_argument('--overwrite', dest="overwrite", action='store_true', default=False, help='Overwrite any existing Tiff/PDF/OCR/Hocr files with new copies.')
    parser.add_argument('--language', dest="language", default='eng', help="Language of the source material, used for OCRing. Defaults to eng.")
    parser.add_argument('--resolution', dest="resolution", type=int, default=300, help="Resolution of the source material, used when generating Tiff. Defaults to 300.")
    parser.add_argument('--use-hocr', dest="use_hocr", action='store_true', default=False, help='Generate OCR by stripping HTML characters from HOCR, otherwise run tesseract. Defaults to use tesseract.')
    parser.add_argument('--mods-dir', dest="mods_dir", default=None, help="Directory of files with a matching name but with the extension '.mods' to be added to the books.")
    parser.add_argument('-d', '--debug', dest="debug_level", choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], default='ERROR', help='Set logging level, defaults to ERROR.')
    args = parser.parse_args()

    if not args.files[0] == '/':
        # Relative filepath
        args.files = os.path.join(os.getcwd(), args.files)
    
    if args.mods_dir is not None:
        if not args.mods_dir[0] == '/':
            # Relative directory
            args.mods_dir = os.path.abspath(args.mods_dir)
        if not (os.path.exists(args.mods_dir) or os.path.isdir(args.mods_dir)):
            parser.error("--mods-dir was not found or is not a directory.")
            quit()
        
    if os.path.isfile(args.files) and os.path.splitext(args.files)[1] == '.pdf':
        setUp(args)
        processPdf(args.files)
    elif os.path.isdir(args.files):
        setUp(args)
        parseDir(args.files)
    else:
        parser.error("{} could not be resolved to a directory or a PDF file".format(args.files))
    
    total_time = time.perf_counter() - start_time
    print("Finished in {}".format(formatTime(total_time)))
        
if __name__ == '__main__':
    main()
    quit()
