#!/usr/bin/env python3
# encoding: utf-8
"""
Multipage 2 PDF to Islandora Book Batch converter

Created by Jared Whiklo on 2016-03-16.
Copyright (c) 2016 University of Manitoba Libraries. All rights reserved.
"""
import sys
import os
import argparse
import re
import logging
import logging.config
import subprocess
import time
import PyPDF2
import html
import shutil
import lxml.etree as ET
import copy

sys.path.append(os.path.dirname(__file__))
from hocrpdf import HocrPdf

"""logger placeholder"""
logger = None

"""External programs needed for this to operate"""
required_programs = [
    {'exec': 'gs', 'check_var': '--help'},
    {'exec': 'convert', 'check_var': '-version'},
    {'exec': 'identify', 'check_var': '-version'}
]

"""External programs needed for creating derivatives."""
derivative_programs = [
    {'exec': 'tesseract', 'check_var': '-v'},
    {'exec': 'kdu_compress', 'check_var': '-version'}
]

"""Options dictionary placeholder, generated by ArgumentParser"""
options = None

"""Regex - Count pages from parsed PDF."""
rxcountpages = re.compile(b"/Type\s*/Page([^s]|$)", re.MULTILINE | re.DOTALL)
"""Regex - Match HTML tags"""
htmlmatch = re.compile(r'<[^>]+>', re.MULTILINE | re.DOTALL)
"""Regex - Match blank lines/characters"""
blanklines = re.compile(r'^[\x01|\x0a|\s]*$', re.MULTILINE)
"""Regex - Match file extensions"""
valid_extensions = re.compile(r'.*\.(pdf|tiff?)$', re.IGNORECASE)
"""Regex - Match PDF extension"""
is_pdf = re.compile(r'.*\.pdf$', re.IGNORECASE)

def preprocess_file(input_file):
    # Check for an existing directory
    book_name = os.path.splitext(os.path.split(input_file)[1])[0]
    book_number = None
    if (options.merge and re.search(r'\d+$', book_name) is not None):
        (book_name, book_number, junk) = re.split(r'(\d+)$', book_name)
    book_name = re.sub(r'\s+', '_', book_name.rstrip())
    if options.output_dir != '.':
        if options.output_dir[0:1] == '/' and os.path.exists(options.output_dir):
            book_dir = os.path.join(options.output_dir, book_name + '_dir')
        elif options.output_dir[0:1] != '/' and os.path.exists(os.path.join(os.getcwd(), options.output_dir)):
            book_dir = os.path.join(os.getcwd(), options.output_dir, book_name + '_dir')
    try:
        if book_dir is not None:
            logger.debug("Output directory was set to {}".format(book_dir))
    except UnboundLocalError:
        # not set, so use old default
        book_dir = os.path.join(os.path.dirname(input_file), book_name + '_dir')
    return book_dir, book_name, book_number


def process_file(input_file):
    """Parse a PDF and produce derivatives

    Keyword arguments
    pdf -- The full path to the input file
    """
    logger.info("Processing {}".format(input_file))
    (book_dir, book_name, book_number) = preprocess_file(input_file)
    mods_file = None
    if not os.path.exists(book_dir):
        os.mkdir(book_dir)
    if options.mods_dir is not None:
        tmpfile = os.path.join(options.mods_dir, book_name + '.mods')
        logger.debug("We have a MODS directory to use {}, look for file {}".format(options.mods_dir, tmpfile))
        if os.path.exists(tmpfile) and os.path.isfile(tmpfile):
            logger.debug("Found file {} and it is a file.".format(tmpfile))
            mods_file = os.path.join(book_dir, 'MODS.xml')
            logger.debug("copy file to {} and set that as mods_file".format(mods_file))
            shutil.copyfile(tmpfile, mods_file)
        else:
            logger.error("Missing MODS file for {}".format(input_file))

    pages = count_pages(input_file)
    logger.debug("counted {} pages in {}".format(pages, input_file))
    if options.merge and book_number is not None:
        boost = count_subdirectories(book_dir)
        logger.debug("There are already {} directories, boosting page count.".format(boost))
    for p in list(range(1, pages + 1)):
        if options.merge and book_number is not None:
            page_number = p + boost
        else:
            page_number = p
        logger.info("Processing page {}".format(str(page_number)))
        out_dir = os.path.join(book_dir, str(page_number))
        if not os.path.exists(os.path.join(book_dir, str(page_number))):
            logger.debug("Creating directory for page {} in {}".format(page_number, book_dir))
            os.mkdir(os.path.join(book_dir, out_dir))
        if is_pdf.match(input_file):
            new_pdf = get_pdf_page(input_file, p, out_dir)
            if not options.skip_derivatives:
                tiff_file = get_tiff(new_pdf, out_dir)
        else:
            tiff_file = get_tiff_page(input_file, p, out_dir)
        if not options.skip_derivatives:
            hocr_file = get_hocr(tiff_file, out_dir)
            get_ocr(tiff_file, hocr_file, out_dir)
            get_jpegs(tiff_file, out_dir)
            if not is_pdf.match(input_file) and os.path.exists(os.path.join(out_dir, 'JP2.jp2')):
                make_pdf(os.path.join(out_dir, 'JP2.jp2'), hocr_file, out_dir)
        if mods_file is not None:
            logger.debug("We have a mods_file.")
            # Copy mods file and insert 
            make_page_mods(filename=mods_file, output_dir=os.path.join(book_dir, out_dir), page=p)
    if not options.skip_derivatives and is_pdf.match(input_file):
        # For our directory scanner, leave this as a manual process for now.
        # Last copy the original PDF to the book level as PDF.pdf
        shutil.copy(input_file, os.path.join(book_dir, 'PDF.pdf'))


def get_tiff(newPdf, outDir):
    """Produce a single page Tiff from a single page PDF

    Keyword arguments
    newPdf -- The full path to the PDF file
    outDir -- The directory to save the single page Tiff to
    """
    logger.debug("in get_tiff")
    resolution = options.resolution
    # Increase density by 25%, then resize to only 75%
    altered_resolution = int(resolution * 1.25)
    output_file = os.path.join(outDir, 'OBJ.tiff')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        # Delete the file if it exists AND we set --overwrite
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        # Only run if the file doesn't exist.
        logger.debug("Generating Tiff")
        op = ['convert', '-density', str(altered_resolution), newPdf, '-resize', '75%', '-colorspace', 'rgb', '-alpha',
              'Off', output_file]
        if not do_system_call(op):
            quit()
    return output_file


def get_tiff_page(tiff_file, page_num, out_dir):
    """Produce a single page Tiff from a multi-page Tiff

    Positional arguments:
    tiff_file - multipage tiff
    page_num - page to extract
    out_dir - The directory to save the image to.
    """
    output_file = os.path.join(out_dir, 'OBJ.tiff')
    adjusted_page = page_num - 1
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Getting Tiff from multi-page Tiff")
        op = ['convert', tiff_file + "[" + str(adjusted_page) + "]", output_file]
        if not do_system_call(op):
            quit()
    return output_file


def get_jpegs(tiff_file, out_dir):
    """Produce the needed JPEGs for ingest.

    Keyword arguments
    tiff_file -- The tiff file
    out_dir -- The directory to save the images to.
    """
    make_jpeg_2000(tiff_file, out_dir)
    make_jpeg(tiff_file, out_dir, 'JPG', height=800, width=800)
    make_jpeg(tiff_file, out_dir, 'TN', height=110, width=110)


def make_jpeg_2000(tiff_file, out_dir):
    size = get_image_size(tiff_file)
    res = get_image_resolution(tiff_file)
    # loseless = (size['height'] < 1024 or size['width'] < 1024 or res['x'] < 300 or res['y'] < 300)
    loseless = True
    just_file = os.path.split(tiff_file)[1]
    output_file = os.path.join(out_dir, 'JP2.jp2')

    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        logger.debug("Generating Jpeg2000")

        if is_compressed(tiff_file):
            new_file = os.path.join(os.path.dirname(tiff_file),
                                   os.path.splitext(just_file)[0] + "_tmp" + os.path.splitext(just_file)[1])
            op = ['convert', '-compress', 'None', tiff_file, new_file]
            do_system_call(op)
        else:
            new_file = tiff_file
        if get_bit_depth(tiff_file) > 8:
            # Use Kakadu
            op = ['kdu_compress', '-i', new_file, '-o', output_file]
            if loseless:
                # Do loseless
                op.extend(['Creversible=yes', '-rate', '-,1,0.5,0.25', 'Clevels=5'])
            else:
                op.extend(['-rate', '0.5', 'Clayers=1', 'Clevels=7',
                           'Cprecincts={256,256},{256,256},{256,256},{128,128},{128,128},{64,64},{64,64},{32,32},{16,16}',
                           'Corder=RPCL', 'ORGgen_plt=yes', 'ORGtparts=R', 'Cblk={32,32}', 'Cuse_sop=yes'])
        else:
            # Use ImageMagick
            op = ['convert']
            op.extend(image_magick_opts(loseless))
            op.extend([new_file, output_file])

        do_system_call(op)

        if new_file != tiff_file:
            # If we made an uncompressed copy, delete it.
            os.remove(new_file)


def make_jpeg(tiff_file, out_dir, out_name, height=None, width=None):
    """Make a Jpeg of max size height x width"""

    op = ['convert', tiff_file]

    output_file = os.path.join(out_dir, out_name + '.jpg')

    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        logger.debug("Creating JPEG with size maximum width and height {}x{}".format(width, height))
        if height is not None or width is not None:
            op.append('-resize')
            if height is not None and width is not None:
                op.append("{}x{}".format(width, height))
            elif width is not None:
                op.append(width)
            else:
                op.append("x{}".format(height))
        op.append(output_file)

        do_system_call(op)


def image_magick_opts(lossless=False):
    """Stores and returns the Kakadu JP2 creation args"""
    args = list()
    args.append(" -depth 8")
    args.append(" -define jp2:tilewidth=1024")
    args.append(" -define jp2:tileheight=1024")
    if lossless:
        args.append(" -define numrlvls=6")
        args.append(" -define jp2:rate=1.0")
        args.append(" -define jp2:lazy")
        args.append(" -define jp2:prg=rlcp")
        args.append(
            " -define jp2:ilyrrates='0.015625,0.01858,0.0221,0.025,0.03125,0.03716,0.04419,0.05,0.0625,0.075,0.088,0.1,0.125,0.15,0.18,0.21,0.25,0.3,0.35,0.4,0.5,0.6,0.7,0.84'")
        args.append(" -define jp2:mode=int")
    else:
        args.append("-define numrlvls=7")
        args.append("-define jp2:rate=0.02348")
        args.append("-define jp2:prg=rpcl")
        args.append("-define jp2:mode=int")
        args.append("-define jp2:prcwidth=16383")
        args.append("-define jp2:prcheight=16383")
        args.append("-define jp2:cblkwidth=64")
        args.append("-define jp2:cblkheight=64")
        args.append("-define jp2:sop")
    return args


def is_compressed(image_file):
    """Does identify see compression on the file."""
    logger.debug("Checking compression for {}".format(image_file))
    op = ['identify', '-format', '%[C]', image_file]
    result = do_system_call(ops=op, return_result=True)
    return result.rstrip('\r\n') != "None"


def get_bit_depth(image_file):
    """Return the bit depth"""
    op = ['identify', '-format', '%[depth]', image_file]
    result = do_system_call(ops=op, return_result=True)
    result = result.rstrip('\r\n')
    logger.debug("Getting the bit depth ({}) for {}".format(result, image_file))
    return int(result)


def get_image_size(image_file):
    """Return a dict of the height and width of the image"""
    logger.debug("Getting the height and width of {}".format(image_file))
    op = ['identify', '-format', '%[height]-%[width]', image_file]
    result = do_system_call(ops=op, return_result=True)
    res_list = result.rstrip('\r\n').split('-')
    return {'height': int(res_list[0]), 'width': int(res_list[1])}


def get_image_resolution(image_file):
    """Return a dict of the X and Y resolutions of the image"""
    logger.debug("Getting the resolutions of {}".format(image_file))
    op = ['identify', '-format', '%x-%y', image_file]
    result = do_system_call(ops=op, return_result=True)
    result = result.rstrip('\r\n')
    if result.lower().find("undefined"):
        result = result.lower().replace("undefined", "")
    res_list = result.split('-')
    res_list = [int(re.search(r'\d+', value).group(0)) for value in res_list]
    logger.debug("Image resolution is " + str(res_list))
    return {'x': res_list[0], 'y': res_list[1]}


def get_pdf_page(pdf, page, out_dir):
    """Produce a single page PDF from a multi-page PDF

    Keyword arguments
    pdf -- The full path to the PDF file
    page -- The page to extract
    out_dir -- The directory to save the single page PDF to

    Returns the path to the new PDF file
    """
    output_file = os.path.join(out_dir, 'PDF.pdf')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        # Delete the file if it exists AND we set --overwrite
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))

    if not os.path.exists(output_file):
        # Only run if the file doesn't exist.
        logger.debug("Generating PDF for page {}".format(str(page)))
        op = ['gs', '-q', '-dNOPAUSE', '-dBATCH', '-dSAFER', '-sDEVICE=pdfwrite', '-dCompatibilityLevel=1.3',
              '-sOutputFile={}'.format(output_file),
              '-dFirstPage={}'.format(str(page)), '-dLastPage={}'.format(str(page)), pdf]
        if not do_system_call(op):
            quit()
    return output_file


def get_ocr(tiff_file, hocr_file, out_dir):
    """Which way to get OCR.

    Keyword arguments
    tiff_file -- Tiff file to process from
    hocr_file -- Hocr file to extract from
    out_dir -- Directory to write OCR file to.
    """
    if tiff_file is not None and os.path.exists(tiff_file) and os.path.isfile(tiff_file) and not options.use_hocr:
        process_ocr(tiff_file, out_dir)
    elif hocr_file is not None and os.path.exists(hocr_file) and os.path.isfile(hocr_file) and options.use_hocr:
        get_ocr_from_hocr(hocr_file, out_dir)
    else:
        logger.error("Unable to generate OCR")


def get_ocr_from_hocr(hocr_file, out_dir):
    """Extract OCR from the Hocr data

    Keyword arguments
    hocr_file -- The HOCR file
    out_dir -- Directory to write OCR file to.
    """
    output_file = os.path.join(out_dir, 'OCR.txt')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating OCR.")
        data = ''
        with open(hocr_file, 'r') as fpr:
            data += fpr.read()
        data = html.unescape(blanklines.sub('', htmlmatch.sub('\1', data)))
        with open(output_file, 'w') as fpw:
            fpw.write(data)


def process_ocr(tiff_file, out_dir):
    """Get the OCR from a Tiff file.

    Keyword arguments
    tiff_file -- The TIFF image
    out_dir -- The output directory"""
    output_file = os.path.join(out_dir, 'OCR.txt')
    output_stub = os.path.join(out_dir, 'OCR')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating OCR.")
        op = ['tesseract', tiff_file, output_stub, '-l', options.language]
        if not do_system_call(op):
            quit()


def get_hocr(tiff_file, out_dir):
    """Get the HOCR from a Tiff file.

    Keyword arguments
    tiff_file -- The TIFF image
    out_dir -- The output directory"""
    output_stub = os.path.join(out_dir, 'HOCR')
    tmp_file = output_stub + '.hocr'
    output_file = output_stub + '.html'
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating HOCR.")
        op = ['tesseract', tiff_file, output_stub, '-l', options.language, 'hocr']
        if not do_system_call(op):
            quit()
        os.rename(tmp_file, output_file)
        if os.path.exists(output_stub + '.txt') and options.use_hocr:
            # Some tesseracts seem to generate OCR at the same time as HOCR,
            # so lets move it to OCR if we are going to create OCR from HOCR.
            os.rename(output_stub + '.txt', os.path.join(out_dir, 'OCR.txt'))
    return output_file


def make_pdf(jp2_file, hocr_file, out_dir):
    """Make PDF out of JP2 and HOCR."""
    hocr = HocrPdf()
    if options.debug_level == 'DEBUG':
        hocr.enable_debug()
    output_file = os.path.join(out_dir, 'PDF.pdf')
    if os.path.exists(output_file) and os.path.isfile(output_file) and options.overwrite:
        os.remove(output_file)
        logger.debug("{} exists and we are deleting it.".format(output_file))
    if not os.path.exists(output_file):
        logger.debug("Generating searchable PDF from tiff and hocr.")
        hocr.create_pdf(image_file=jp2_file, hocr_file=hocr_file, pdf_filename=output_file, dpi=options.resolution)


def make_page_mods(filename, output_dir, page):
    """Using a Book level MODS record insert the relatedItem/part information
    
    Keyword arguments
    filename -- The filename of the top level MODS file
    output_dir -- The page level directory to save the MODS to
    page -- The page number"""
    mods_namespace = '{http://www.loc.gov/mods/v3}'
    logger.debug("In make_page_mods")
    if os.path.exists(filename) and os.path.isfile(filename):
        logger.debug("Have file {}".format(filename))
        try:
            tree = ET.parse(filename)
        except:
            logger.error("Error parsing MODS in file {}: {}".format(filename, sys.exc_info()[0]))
            return
        related = tree.find("{0}relatedItem[@type=\"host\"]".format(mods_namespace))
        if related is None:
            root = tree.getroot()
            related = ET.SubElement(root, "{0}relatedItem".format(mods_namespace), {'type': 'host'})
        if related.find("{0}titleInfo/{0}title".format(mods_namespace)) is None:
            title = tree.find("{0}titleInfo/{0}title".format(mods_namespace))
            if title is None:
                logger.warning("Unable to locate the title page {}".format(page))
            else:
                tmp = ET.Element("{0}titleInfo".format(mods_namespace))
                tmp.append(copy.deepcopy(title))
                related.append(tmp)
                logger.debug("Copied titleInfo to relatedItem, now add page number to top level titleInfo/title")
                title.text = title.text + ' (Page {})'.format(page)
        part = related.find("{0}path".format(mods_namespace))
        if part is None:
            part = ET.SubElement(related, '{0}part'.format(mods_namespace))
        extent = part.find("{0}extent[@unit=\"pages\"]".format(mods_namespace))
        if extent is None:
            extent = ET.SubElement(part, "{0}extent".format(mods_namespace), {'unit': 'pages'})
        start = extent.find("./{0}start".format(mods_namespace))
        if start is not None:
            start.getparent().remove(start)
        start = ET.SubElement(extent, '{0}start'.format(mods_namespace))
        start.text = str(page)
        end = extent.find('./{0}end'.format(mods_namespace))
        if end is not None:
            end.getparent().remove(end)
        end = ET.SubElement(extent, '{0}end'.format(mods_namespace))
        end.text = str(page)
        # Remove the book level page count
        phys_desc = tree.find("{0}physicalDescription/{0}extent[@unit=\"pages\"]".format(mods_namespace))
        if phys_desc is not None:
            phys_desc.getparent().remove(phys_desc)

        try:
            tree.write(os.path.join(output_dir, 'MODS.xml'), encoding='utf-8', xml_declaration=True, method='xml')
        except IOError as e:
            logger.error("Error writing out page level MODS to directory {}: {}".format(output_dir, e))


def do_system_call(ops, return_result=False):
    """Execute an external system call

    Keyword arguments
    ops -- a list of the executable and any arguments.
    return_result -- return the result of the call if successful.
    """
    try:
        process = subprocess.Popen(ops, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        try:
            outs, errs = process.communicate(timeout=60)
            if not process.returncode == 0:
                logger.error("Error executing command: \n{}\nOutput: {}\nError: {}".format(' '.join(ops), outs, errs))
                return False
        except TimeoutError as e:
            logger.error(
                "Error executing command: \n{}\nMessage: {}\nOutput: {}\nSTDOUT: ".format(e.cmd, e.stderr, e.output,
                                                                                          e.stdout))
            return False
    except subprocess.CalledProcessError as e:
        logger.error(
            "Error executing command: \n{}\nMessage: {}\nOutput: {}\nSTDOUT: ".format(e.cmd, e.stderr, e.output,
                                                                                      e.stdout))
        return False
    logger.debug("Command result:\n{}".format(outs))
    if return_result:
        return outs
    else:
        return True


def count_pages(input_file):
    """Count the number of pages in a file

    Keyword arguments
    input_file -- the full path to the input file
    """
    count = 0
    if is_pdf.match(input_file):
        with open(input_file, 'rb') as fp:
            count += len(rxcountpages.findall(fp.read()))
        if count == 0:
            pdf_read = PyPDF2.PdfFileReader(input_file)
            count = pdf_read.getNumPages()
            pdf_read = None
    else:
        ops = [
            'identify', '-ping', '-format', "%n\\n", input_file
        ]
        results = do_system_call(ops, return_result=True)
        count = int(results.rstrip().split('\n').pop())

    return count


def count_subdirectories(the_dir):
    if os.path.exists(the_dir):
        subdirs = [f for f in os.listdir(the_dir) if os.path.isdir(os.path.join(the_dir, f))]
        return len(subdirs)
    else:
        return 0


def parse_dir(the_dir):
    """Act on all valid files in a directory, not recursing down.

    Keyword arguments
    the_dir -- The full path to the directory to operate on
    """
    files = [f for f in os.listdir(the_dir) if valid_extensions.search(f)]
    processed = list()
    for f in files:
        if f in processed:
            continue
        book_name = os.path.splitext(os.path.split(f)[1])[0]
        if options.merge and re.search(r'\d+$', book_name) is not None:
            (book_name, book_number, junk) = re.split(r'(\d+)$', book_name)
            other_books = [re.split(r'(\d+)(\.)', f) for f in os.listdir(the_dir) if re.match(r'' + book_name + '\d+\.', f)]
            other_books = sorted(other_books, key=lambda x: int(x[1]))
            other_books = [''.join(f) for f in other_books]
            for fx in other_books:
                processed.append(fx)
            # Before we start make sure the target directory is empty
            (book_dir, name, number) = preprocess_file(other_books[0])
            if count_subdirectories(book_dir) > 0:
                mesg = "We are attempting to merge {} files into {} and there are already existing subdirectories. " \
                       "This must be an empty directory".format(len(other_books), book_dir)
                logger.error(mesg)
                print("ERROR: " + mesg)
                quit()
            for same_books in other_books:
                # Process all books together in sequence
                process_file(os.path.join(the_dir, same_books))
        else:
            process_file(os.path.join(the_dir, f))


def set_up(args):
    """Do setup functions

    Keyword arguments
    args -- the ArgumentParser object
    """
    global options
    options = args
    setup_log()
    if options.skip_derivatives:
        test_programs = required_programs
    else:
        test_programs = required_programs
        test_programs.extend(derivative_programs)

        try:
            for prog in test_programs:
                subprocess.run([prog.get('exec'), prog.get('check_var')], stdout=subprocess.DEVNULL,
                               stderr=subprocess.DEVNULL, check=True)
        except FileNotFoundError as e:
            print("A required program could not be found: {}".format(e.strerror.split(':')[1]))
            quit()


def setup_log():
    """Setup logging"""
    global logger
    logger = logging.getLogger('multipage2book')
    logger.propogate = False
    # Logging Level 
    eval('logger.setLevel(logging.{})'.format(options.debug_level))
    filename = os.path.join(os.getcwd(), 'multipage2book.log')
    fh = logging.FileHandler(filename, 'w', 'utf-8')
    formatter = logging.Formatter('%(asctime)s %(name)-12s %(levelname)-8s %(message)s')
    fh.setFormatter(formatter)
    logger.addHandler(fh)


def format_time(seconds):
    """Format seconds """
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    return "%d:%02d:%02d" % (h, m, s)


def main():
    """The main body of code"""
    start_time = time.perf_counter()

    parser = argparse.ArgumentParser(
        description='Turn a PDF/Tiff or set of PDFs/Tiffs into properly formatted directories for Islandora Book Batch.')
    parser.add_argument('files', help="A file or directory of files to process.")
    parser.add_argument('--password', dest="password", default='', help='Password to use when parsing PDFs.')
    parser.add_argument('--overwrite', dest="overwrite", action='store_true', default=False,
                        help='Overwrite any existing Tiff/PDF/OCR/Hocr files with new copies.')
    parser.add_argument('--language', dest="language", default='eng',
                        help="Language of the source material, used for OCRing. Defaults to eng.")
    parser.add_argument('--resolution', dest="resolution", type=int, default=300,
                        help="Resolution of the source material, used when generating Tiff. Defaults to 300.")
    parser.add_argument('--use-hocr', dest="use_hocr", action='store_true', default=False,
                        help='Generate OCR by stripping HTML characters from HOCR, otherwise run tesseract a second '
                             'time. Defaults to use tesseract.')
    parser.add_argument('--mods-dir', dest="mods_dir", default=None,
                        help='Directory of files with a matching name but with the extension ".mods" to be added to '
                             'the books.')
    parser.add_argument('--output-dir', dest="output_dir", default=".",
                        help="Directory to build books in, defaults to current directory.")
    parser.add_argument('--merge', dest="merge", action='store_true', default=False,
                        help='Files that have the same name but with a numeric suffix are considered the '
                             'same book and directories are merged. (ie. MyBook1.pdf and MyBook2.pdf)')
    parser.add_argument('--skip-derivatives', dest="skip_derivatives", action='store_true', default=False,
                        help='Only split the source file into the separate pages and directories, don\'t generate '
                             'derivatives.')
    parser.add_argument('-l', '--loglevel', dest="debug_level", choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        default='ERROR', help='Set logging level, defaults to ERROR.')
    args = parser.parse_args()

    if not args.files[0] == '/':
        # Relative filepath
        args.files = os.path.join(os.getcwd(), args.files)

    if args.mods_dir is not None:
        if not args.mods_dir[0] == '/':
            # Relative directory
            args.mods_dir = os.path.abspath(args.mods_dir)
        if not (os.path.exists(args.mods_dir) or os.path.isdir(args.mods_dir)):
            parser.error("--mods-dir was not found or is not a directory.")
            quit()
    if args.merge and args.overwrite:
        parser.error("--merge and --overwrite are mutually exclusive options, you can only use one at a time.")

    if args.merge:
        print("Warning: merge attempts to combine multiple files that start with the same name and end with a digit "
              "before the extension. Files are sorted by the number and require an empty starting directory. If the "
              "expected directory contains files, it will halt with a warning.")
        input("Press any key to proceed")

    if os.path.isfile(args.files) and valid_extensions.match(args.files):
        set_up(args)
        process_file(args.files)
    elif os.path.isdir(args.files):
        set_up(args)
        parse_dir(args.files)
    else:
        parser.error("{} could not be resolved to a directory or a PDF file".format(args.files))

    total_time = time.perf_counter() - start_time
    print("Finished in {}".format(format_time(total_time)))


if __name__ == '__main__':
    main()
    quit()
